# `level 1` 완주하지 못한 선수 
https://school.programmers.co.kr/learn/courses/30/lessons/42576

## 문제 설명

수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.

## 제한사항
- 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
- completion의 길이는 participant의 길이보다 1 작습니다.
- 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
- 참가자 중에는 동명이인이 있을 수 있습니다.

![image](https://user-images.githubusercontent.com/122213470/229139309-17d4195b-364b-4bf9-bdf3-bd7929e05e17.png)

## Solution 1. (실페)

알고리즘
- participant 에서 completion의 원소를 하나씩 pop 하기 (중복되는 것이 있으므로 pop 하는 것을 생각)

Point:
- Use `enumerate`
- Use `pop`
- Use `.index` - **이거 검색해봄**
- 동명이인이 있을 수 있음에 유의
- 출력은 리스트가 아니라 string의 형태로 해야 함

결과:
- 정확성 테스트에서는 모두 통과되지만 효율성 테스트를 하나도 통과하지 못했다.

```python
def solution(participant, completion):
    for i, x in enumerate(completion):
        participant.pop(participant.index(x))
    answer = participant[0]
    return answer
```

## Solution 2. (실패)

Point:
- Use `del` instead of `pop`

결과:
- 마찬가지로 시간 초과

```python
def solution(participant, completion):
    for i, x in enumerate(completion):
        del participant[participant.index(x)]
    answer = participant[0]
    return answer
```

## Solution 3. (더 실패)

알고리즘:
- 각 리스트를 정렬해서 순서대로 탐색했을 때 다른 값이 나온다면 participant의 해당 값을 return
- 단, participant의 마지막에 answer이 있는 경우를 따로 처리해야 함

결과:
- 시간 초과 & 정확성 테스트 7개 중 5개 실패

```python
def solution(participant, completion):
    participant.sort()
    completion.sort()
    answer = []
    for i, x in enumerate(completion):
        if x != participant[i]:
            answer = participant[i]
    if answer == []:
        answer = participant[-1]
    return answer
```


